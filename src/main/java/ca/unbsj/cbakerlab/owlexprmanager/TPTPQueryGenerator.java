package ca.unbsj.cbakerlab.owlexprmanager;

//import ca.unbsj.cbakerlab.codegenerator.GenerateSADIService;

//%import com.ctc.wstx.util.StringUtil;
import com.hp.hpl.jena.util.FileUtils;
import com.tinkerpop.blueprints.Direction;
import com.tinkerpop.blueprints.Edge;
import com.tinkerpop.blueprints.Graph;
//import com.tinkerpop.blueprints.Vertex;

//import org.apache.commons.io.IOUtils;
import org.apache.commons.lang.StringUtils;
//import org.coode.owlapi.manchesterowlsyntax.ManchesterOWLSyntaxClassExpressionParser;
import org.semanticweb.owlapi.model.*;

import java.io.IOException;
import java.util.*;

/**
 * Created by sadnana on 15/07/15.
 */
public class TPTPQueryGenerator {

    public Set<OWLClass> classes;
    public Set<OWLDataProperty> dataProperties;
    public Set<OWLObjectProperty> objectProperties;

    public static List<String> cls_predicate_List = new ArrayList<String>();
    // collects answer variables only from the output class description (datatype only)
    public static List<String> answerVars = new ArrayList<String>();
    public static List<String> answerClsPred = new ArrayList<String>();

    String includeFiles;
    String queryPrefix;
    String querySuffix;
    
    boolean rootNodeinInputGraph = false;
    
    //public static final String ONT_RDB_MAPPING_FILENAME = "my_university_semantic_map.fof.tptp";
    //public static final String ONT_RDB_MAPPING_FILENAME = "tohdw_haio_semantic_map.fof.tptp";
    public static final String ONT_RDB_MAPPING_FILENAME = "rdb2ont.tptp";
    //public static final String ONT_TO_TPTP_FILENAME = "lubm-sadi-service-ontology.cnf.tptp";    
    public static final String ONT_TO_TPTP_FILENAME = "HAI_no_Illegal_Symbols.ontology.cnf.tptp";


    /**
     * @param inputGraph  set of input graphs
     * @param outputGraph set of output graphs
     * @return TPTP query generated from both input and output graph
     */
    public String generateTPTPQuery(OWLOntology ontology, List<Graph> inputGraph, List<Graph> outputGraph) {


        includeFiles =
                "% mapping of ontology to relation data \n" +
                "include('" + ONT_RDB_MAPPING_FILENAME + "'). \n\n" +
                "% ontology translated into tptp formulas \n" +
                "include('" + ONT_TO_TPTP_FILENAME + "'). \n\n";
        queryPrefix =
                "% semantic query \n" +
                "input_clause(autogeneratedquery,conjecture, \n" + "  [";
        querySuffix = "\n  ]).";




        classes = ontology.getClassesInSignature();
        dataProperties = ontology.getDataPropertiesInSignature();
        objectProperties = ontology.getObjectPropertiesInSignature();


        boolean isOutputClsDescription;

        String tptpQuery = "";
        
        // generate tptp part of input graph rooted at 'Input' node
        for (Graph igraph : inputGraph) {
            isOutputClsDescription = false;
            List<Edge> ipEdgesList = sortEdgesInDFS(igraph.getEdges());
            //addClsPredicatesToList(ipEdgesList, isOutputClsDescription);
            addClsPredToListFromInGraph(ipEdgesList, isOutputClsDescription);
        }

        // generate tptp part of input graph rooted at 'Input' node
        for (Graph ograph : outputGraph) {
            isOutputClsDescription = true;
            List<Edge> opEdgesList = sortEdgesInDFS(ograph.getEdges());
            //addClsPredicatesToList(opEdgesList, isOutputClsDescription);
            addClsPredToListFromOpGraph(opEdgesList, isOutputClsDescription);
        }

        String prefixAtom = "--p_";
        String prefixAnswer = "++";
        tptpQuery += createTPTPfof(prefixAtom, prefixAnswer, cls_predicate_List, answerVars);


        return includeFiles + queryPrefix + tptpQuery + querySuffix;
    }


	private void addClsPredToListFromInGraph(List<Edge> ipEdgesList,
			boolean isOutputClsDescription) {
		
		for(Edge edge : ipEdgesList){
			// consider only edge labels with property
			if(!edge.getLabel().equals("")){
				// object property
				if (!checkPropertyType(objectProperties, dataProperties, edge.getLabel())) {
					
					if(edge.getLabel().equals("type")){
						
						/**
						 * Only root node is common to both graph. If the input class description has a resource in the root node
						 * e.g. 'input class description /equiv Patient', and output is 'has_first_name some string' so the 
						 * property 'has_first_name' attached to the root node in the output graph also has the 
						 * same domain e.g. has_first_name(entityForPatient("INPUT"), patFirstname).
						 * 
						 * On the other hand, if it is the other way around i.e. if the input class description is 
						 * e.g. 'has_first_name some string' and output description is 'Patient', then
						 * has_first_name(INPUT, patFirstname) is sufficient. 
						 */
						if(edge.getVertex(Direction.OUT).getId().equals("0")){
							rootNodeinInputGraph = true;
						}
						/* parent node class name e.g. 'Patient' represents a primary key in table with patWID attribute,
						 * which is presented in the mapping file as 'p_Patient(entityFor(Patient'  ....... 
						 * */ 
						if(isDefinedEntity(edge.getVertex(Direction.OUT).getProperty("tptpNodeName").toString()))
							System.out.println(edge.getVertex(Direction.OUT).getProperty("tptpNodeName").toString()+ " defined as entity");
						else
							System.out.println(edge.getVertex(Direction.OUT).getProperty("tptpNodeName").toString() + " NOT defined as entity");
						
						if(isDefinedEntity(edge.getVertex(Direction.OUT).getProperty("tptpNodeName").toString())){
							cls_predicate_List.add(edge.getVertex(Direction.IN).getProperty("name").toString() 
                    			+ "("
                    			+ createParamWithClsAsIpValue(edge.getVertex(Direction.OUT).getProperty("tptpNodeName").toString(), edge.getVertex(Direction.OUT).getProperty("nodeVariableName").toString().toUpperCase())                    			 
                    			+ ")");
						}
						else{
							cls_predicate_List.add(edge.getVertex(Direction.IN).getProperty("name").toString() 
	                    			+ "("
	                    			+ edge.getVertex(Direction.OUT).getProperty("nodeVariableName").toString().toUpperCase()                    			 
	                    			+ ")");
						}
					}
					else if (edge.getLabel().equals("subClassOf")) { // probably should cover 'subClassOf value individual'
                        //System.out.println("Predicate generation for subClassOf NOT implemented yet");
                        // probably not covering 'subClassOf value class/individual'
						cls_predicate_List.add(edge.getVertex(Direction.IN).getProperty("name").toString() + "(" + edge.getVertex(Direction.OUT).getProperty("nodeVariableName").toString().toUpperCase() + ")");
                    }else{// courseTaken( entityForCourse("INPUT"), )
                    	/* Covers inputclass equivalent to
                    	 * Course and (courseTaken some Student) and (offeredBy some Department)
                    	 * Here both object property has the same node Course
                    	 * */
                    	boolean foundSameObjPropRoot = false;
    					String parentObjectProptptpNode =  edge.getVertex(Direction.OUT).getProperty("tptpNodeName").toString();
    					for(Edge eachEdge : ipEdgesList){
    						if(eachEdge.getLabel().equals("type") && eachEdge.getVertex(Direction.OUT).getProperty("tptpNodeName").toString().equals(parentObjectProptptpNode)){
    							foundSameObjPropRoot = true;
    						}
    					}
    					
                    	if(foundSameObjPropRoot && isDefinedEntity(edge.getVertex(Direction.OUT).getProperty("tptpNodeName").toString())){
                    		cls_predicate_List.add(edge.getLabel() 
                    			+ "("
                    			+ createParamWithClsAsIpValue(edge.getVertex(Direction.OUT).getProperty("tptpNodeName").toString(), edge.getVertex(Direction.OUT).getProperty("nodeVariableName").toString().toUpperCase())                    			 
                    			+ ", " 
                    			+ edge.getVertex(Direction.IN).getProperty("nodeVariableName").toString().toUpperCase()  
                    			+ ")");
                    	}else{                    	
                    		cls_predicate_List.add(edge.getLabel() 
                    			+ "(" 
                    			+ edge.getVertex(Direction.OUT).getProperty("nodeVariableName").toString().toUpperCase() 
                    			+ ", " 
                    			+ edge.getVertex(Direction.IN).getProperty("nodeVariableName").toString().toUpperCase()  
                    			+ ")");
                    	}
                    	 
                    	 
                    }
				}// object property end
				// data property
				else{
					boolean foundSameDataPropRoot = false;
					String parentDataProptptpNode =  edge.getVertex(Direction.OUT).getProperty("tptpNodeName").toString();
					for(Edge eachEdge : ipEdgesList){
						if(eachEdge.getLabel().equals("type") && eachEdge.getVertex(Direction.OUT).getProperty("tptpNodeName").toString().equals(parentDataProptptpNode)){
							foundSameDataPropRoot = true;
						}
					}
					
					if(foundSameDataPropRoot && isDefinedEntity(edge.getVertex(Direction.OUT).getProperty("tptpNodeName").toString())){
						cls_predicate_List.add(edge.getLabel() 
								+ "(" 
								+ createParamWithClsAsIpValue(edge.getVertex(Direction.OUT).getProperty("tptpNodeName").toString(), edge.getVertex(Direction.OUT).getProperty("nodeVariableName").toString().toUpperCase())
								//+ edge.getVertex(Direction.OUT).getProperty("nodeVariableName").toString().toUpperCase() 
								+ ", " 
								+ "\"" + "val" + edge.getVertex(Direction.IN).getProperty("nodeVariableName").toString() + "\"" 
								+ ")");
					}
					else{
						cls_predicate_List.add(edge.getLabel() + "(" + edge.getVertex(Direction.OUT).getProperty("nodeVariableName").toString().toUpperCase() + ", " + "\"" + "val" + edge.getVertex(Direction.IN).getProperty("nodeVariableName").toString() + "\"" + ")");
					}
					
					
					
					
					
					/*
					if(!edge.getVertex(Direction.OUT).getProperty("tptpNodeName").toString().equals("")){
						cls_predicate_List.add(edge.getLabel() 
								+ "(" 
								+ createParamWithClsAsIpValue(edge.getVertex(Direction.OUT).getProperty("tptpNodeName").toString(), edge.getVertex(Direction.OUT).getProperty("nodeVariableName").toString().toUpperCase())
								//+ edge.getVertex(Direction.OUT).getProperty("nodeVariableName").toString().toUpperCase() 
								+ ", " 
								+ "\"" + "val" + edge.getVertex(Direction.IN).getProperty("nodeVariableName").toString() + "\"" 
								+ ")");
					}
					else{
						cls_predicate_List.add(edge.getLabel() + "(" + edge.getVertex(Direction.OUT).getProperty("nodeVariableName").toString().toUpperCase() + ", " + "\"" + "val" + edge.getVertex(Direction.IN).getProperty("nodeVariableName").toString() + "\"" + ")");
					}
					*/
				}// data property ends
			}
				
		}
	}

    


	private void addClsPredToListFromOpGraph(List<Edge> opEdgesList,
			boolean isOutputClsDescription) {
		
		for(Edge edge : opEdgesList){
			// consider only edge labels with property
			if(!edge.getLabel().equals("")){
				// object property
				if (!checkPropertyType(objectProperties, dataProperties, edge.getLabel())) {
					/**
					 * It seems that only 'type' (and 'subClassOf value class/individual') should be enough 
					 * to represent the primary key e.g., patWID, digWID etc using 'entityForClassname' i.e. 'entityForPatient'. 
					 * Other object properties should be ok without 
					 */
					if(edge.getLabel().equals("type")){
						cls_predicate_List.add(edge.getVertex(Direction.IN).getProperty("name").toString() + "(" + edge.getVertex(Direction.OUT).getProperty("nodeVariableName").toString().toUpperCase() + ")");
						// add to the output variable list
						answerVars.add(edge.getVertex(Direction.OUT).getProperty("nodeVariableName").toString().toUpperCase());
						// name of the class, to be used later for matching the SELECT variables e.g., column name patWID 
						answerClsPred.add(edge.getVertex(Direction.IN).getProperty("name").toString());
					}
					else if (edge.getLabel().equals("subClassOf")) { // probably should cover 'subClassOf value individual'                        
						cls_predicate_List.add(edge.getVertex(Direction.IN).getProperty("name").toString() + "(" + edge.getVertex(Direction.OUT).getProperty("nodeVariableName").toString().toUpperCase() + ")");
                    }else{                           
                    	Integer currentDegree = edge.getVertex(Direction.IN).getProperty("degree");
                    	if(currentDegree > 0)
                    		if( (rootNodeinInputGraph == true && edge.getVertex(Direction.OUT).getId().equals("0")) 
        							|| (rootNodeinInputGraph == true && edge.getVertex(Direction.OUT).getProperty("nodeVariableName").equals("input")) ){
        						cls_predicate_List.add(edge.getLabel() 
        								+ "(" 
        								+ createParamWithClsAsIpValue(edge.getVertex(Direction.OUT).getProperty("tptpNodeName").toString(), edge.getVertex(Direction.OUT).getProperty("nodeVariableName").toString().toUpperCase())
        								//+ edge.getVertex(Direction.OUT).getProperty("nodeVariableName").toString().toUpperCase() 
        								+ ", " + edge.getVertex(Direction.IN).getProperty("nodeVariableName").toString().toUpperCase()  + ")");
        					}                    		
                    		else
                    			cls_predicate_List.add(edge.getLabel() + "(" + edge.getVertex(Direction.OUT).getProperty("nodeVariableName").toString().toUpperCase() + ", " + edge.getVertex(Direction.IN).getProperty("nodeVariableName").toString().toUpperCase()  + ")");
                    	else{
                    		cls_predicate_List.add(edge.getLabel() + "(" + edge.getVertex(Direction.OUT).getProperty("nodeVariableName").toString().toUpperCase() + ", " + edge.getVertex(Direction.IN).getProperty("nodeVariableName").toString().toUpperCase()  + ")");
                    		// add to the output variable list
    						answerVars.add(edge.getVertex(Direction.IN).getProperty("nodeVariableName").toString().toUpperCase());
    						// name of the class, to be used later for matching the SELECT variables e.g., column name patWID 
    						answerClsPred.add(edge.getVertex(Direction.IN).getProperty("name").toString());
                    	}
                    }
				}// object property end
				// data property
				else{
					System.out.println("value of rootNodeinInputGraph : "+edge.getVertex(Direction.OUT).getProperty("nodeVariableName").toString());
					// (has_first_name some string) || ( (has_first_name some string) and (has_last_name some string) )
					if( (rootNodeinInputGraph == true && edge.getVertex(Direction.OUT).getId().equals("0")) 
							|| (rootNodeinInputGraph == true && edge.getVertex(Direction.OUT).getProperty("nodeVariableName").equals("input")) ){
						cls_predicate_List.add(edge.getLabel() 
								+ "(" 
								+ createParamWithClsAsIpValue(edge.getVertex(Direction.OUT).getProperty("tptpNodeName").toString(), edge.getVertex(Direction.OUT).getProperty("nodeVariableName").toString().toUpperCase())
								//+ edge.getVertex(Direction.OUT).getProperty("nodeVariableName").toString().toUpperCase() 
								+ ", " 
								+ "VAL" + edge.getVertex(Direction.IN).getProperty("nodeVariableName").toString().toUpperCase() 
								+ ")");
					}
					else
						cls_predicate_List.add(edge.getLabel() + "(" + edge.getVertex(Direction.OUT).getProperty("nodeVariableName").toString().toUpperCase() + ", " + "VAL" + edge.getVertex(Direction.IN).getProperty("nodeVariableName").toString().toUpperCase() + ")");
					
					   // add to the list of answer variables if data property is in output class description
                    //if(isOutputClsDescription)
                        answerVars.add("VAL" + edge.getVertex(Direction.IN).getProperty("nodeVariableName").toString().toUpperCase());
                        answerClsPred.add(edge.getLabel());
				}// data property ends
			}
				
		}
	}
    
    /*
    private void addClsPredicatesToList(List<Edge> edgesList, boolean isOutputClsDescription) {
        for (Edge edge : edgesList) {
            // consider only data and object property edge, other edges have no labels
            if (!edge.getLabel().equals("")) {
                // if the edge label is an object property
                if (!checkPropertyType(objectProperties, dataProperties, edge.getLabel())) {
                    // the node with this incoming edge is a class
                    // Input rdf:type Course -> Course(Input)
                    // Alternatively, this can also be done by checking each node if it is a class e.g. Course, Student in the graph and
                    // if they are, then create an unary predicate Course(edge.getVertex(Direction.OUT).getProperty("nodeVariableName").toString())
                    if (edge.getLabel().equals("type")) {
                    	//System.out.println(edge.getVertex(Direction.OUT).getPropertyKeys());
                        //cls_predicate_List.add(edge.getVertex(Direction.IN).getProperty("name").toString() + "(" + edge.getVertex(Direction.OUT).getProperty("nodeVariableName").toString().toUpperCase() + ")");

                        cls_predicate_List.add(edge.getVertex(Direction.IN).getProperty("name").toString() 
                        			+ "("
                        			+ createParamWithClsAsIpValue(edge.getVertex(Direction.OUT).getProperty("tptpNodeName").toString(), edge.getVertex(Direction.OUT).getProperty("nodeVariableName").toString().toUpperCase())                    			 
                        			+ ")");
                    }
                    // A subClassOf B ->  A(p)=>B(p)
                    else if (edge.getLabel().equals("subClassOf")) {
                        //System.out.println("Predicate generation for subClassOf NOT implemented yet");
                        cls_predicate_List.add(edge.getVertex(Direction.IN).getProperty("name").toString() + "(" + edge.getVertex(Direction.OUT).getProperty("nodeVariableName").toString().toUpperCase() + ")");
                    }
                    // Input courseTaken CommonResource1 -> courseTaken(Input, CommonResource1)
                    // Does NOT cover 'InputClass equivalent (procedure_has_type value Operative_procedure)'
                    else {
                    	
                    	
                        cls_predicate_List.add(edge.getLabel() + "(" + edge.getVertex(Direction.OUT).getProperty("nodeVariableName").toString().toUpperCase() + ", " + edge.getVertex(Direction.IN).getProperty("nodeVariableName").toString().toUpperCase()  + ")");
                    }
                    // for the data property add Val + the name of the node stored as a vertex property nodeVariableName
                } else {

                    if(!isOutputClsDescription){// (Patient and has_first_name string)
                    	// the subject of this data property is an instance of class e.g. Patient, NOT empty
                    	if(!edge.getVertex(Direction.OUT).getProperty("tptpNodeName").equals("")){
                    		cls_predicate_List.add(edge.getLabel() + "(" +
                    				createParamWithClsAsIpValue(edge.getVertex(Direction.OUT).getProperty("tptpNodeName").toString(), edge.getVertex(Direction.OUT).getProperty("nodeVariableName").toString().toUpperCase())
                    				+ ", " + "\"" + "val" + edge.getVertex(Direction.IN).getProperty("nodeVariableName").toString() + "\"" + ")");
                    	}
                    	else // not sure if this will ever be used
                    		cls_predicate_List.add(edge.getLabel() + "(" + edge.getVertex(Direction.OUT).getProperty("nodeVariableName").toString().toUpperCase() + ", " + "\"" + "val" + edge.getVertex(Direction.IN).getProperty("nodeVariableName").toString() + "\"" + ")");
                    }
                    else{
                        cls_predicate_List.add(edge.getLabel() + "(" + edge.getVertex(Direction.OUT).getProperty("nodeVariableName").toString().toUpperCase() + ", " + "VAL" + edge.getVertex(Direction.IN).getProperty("nodeVariableName").toString().toUpperCase() + ")");
                    }
                    // add to the list of answer variables if data property is in output class description
                    if(isOutputClsDescription)
                        answerVars.add("VAL" + edge.getVertex(Direction.IN).getProperty("nodeVariableName").toString().toUpperCase());

                }

            }

        }

    }
    */

    private String createTPTPfof(String prefixAtom, String prefixAnswer, List<String> cls_predicate_list, List<String> answerVars) {
        String query = "";

        for(int i = 0; i < cls_predicate_list.size(); i++){
            query += (i > 0)? "," + "\n\t" + prefixAtom + cls_predicate_list.get(i) :  "\n\t" +prefixAtom + cls_predicate_list.get(i);
        }

        query +=  ", " + "\n\t" + prefixAnswer  + "answer" + "(";
        for(int i = 0; i < answerVars.size(); i++){
            query += (i > 0)? "," + answerVars.get(i) : answerVars.get(i);
        }

        query += ")";

        return query;
    }


    /**
     * @param edges
     * @return sort the edges of the graph in ordre of generation i.e. DFS
     */
    private static List<Edge> sortEdgesInDFS(Iterable<Edge> edges) {
        List<Edge> sortedEdges = new ArrayList<Edge>();

        for (Edge e : edges) {
            sortedEdges.add(e);
        }

        Collections.sort(sortedEdges, new Comparator<Edge>() {
            public int compare(Edge e1, Edge e2) {
                //based on number of edge ID
                return Integer.parseInt(e1.getId().toString()) - Integer.parseInt(e2.getId().toString());
            }
        });
        return sortedEdges;
    }


    /**
     * @param objectProperties set of object properties
     * @param dataProperties   set of data properties
     * @param propertyLabel    edge label i.e. property name
     * @return ture if the edge/property is data property
     */
    private boolean checkPropertyType(Set<OWLObjectProperty> objectProperties, Set<OWLDataProperty> dataProperties, String propertyLabel) {
        boolean result = false;

        for (OWLDataProperty dp : dataProperties) {
            if (dp.getIRI().getFragment().equals(propertyLabel)) {
                result = true;
            }
        }
        for (OWLObjectProperty op : objectProperties) {
            if (op.getIRI().getFragment().equals(propertyLabel)) {
                result = false;
            }
        }
        return result;
    }
    
    
    private String createParamWithClsAsIpValue(String className, String variableName) {
		String result = "";
		result = "entityFor" + className + "(\"" + variableName + "\")";
		return result;
	}
    
    public static boolean isDefinedEntity(String parentClassName) {
    	//String searchString = "p_" + parentClassName + "entityFor" + parentClassName;
    	String searchString = "entityFor" + parentClassName;
    	String mappingFile = "";
    	try {
			mappingFile = FileUtils.readWholeFileAsUTF8(TPTPQueryGenerator.class.getResourceAsStream("/" + ONT_RDB_MAPPING_FILENAME));			
			System.out.println("Mapping file "+ ONT_RDB_MAPPING_FILENAME + " is found and read as UTF8");
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
    	// if there any any content
    	if(!mappingFile.equals("")){
    		String contentInBetween = StringUtils.substringBetween(mappingFile, "p_"+parentClassName, "entityFor" + parentClassName).trim();
    		if(StringUtils.containsOnly(contentInBetween, "(")){
    			System.out.println("'(' is found between " +   "p_"+parentClassName + " and " + "entityFor" + parentClassName);
    			return true;
    		}
    			
    		
    		//if(StringUtils.contains(mappingFile, searchString))
    			//return true;
    	}
    	
    	
    	
		return false;
	}
}